# Chapter 07. 객체 분해

사람이 문제를 해결하기 주요하게 사용되는 저장소는 단기기억 저장소이다. 하지만 기억해야 하는 정보의 개수가 용량을 초과하면 문제 해결 능력이 급격히 떨어진다. 이를 인지 부조화 라고 명칭한다. 
이를 해결하기 위해서는 불필요한 정보를 제거하고 핵심 정보만 남기는 작업이 필요하다. 이를 추상화라 부른다.
가장 일반적인 추상화 방법은 한번에 맞닥뜨리는 문제의 크기를 줄이는 것이다. 이를 분해라고 한다.
사람이 기억하는 정보의 개수는 한정적이지만, 이 정보는 가장 작은 단위의 개별항목이 아닌 청크단위를 의미한다. 따라서 정보를 어떤 개념적 청크로 묶으면 인지 능력 향상 시킬 수 있다. (랜덤 숫자 vs 전화번호)

- 추상화의 수에는 한계가 있지만 더 큰 규모의 추상화를 통해 단기 기억의 한계를 초월할 수 있다. 
- 소프트웨어 개발 영역에서 추상화와 분해가 어떤식으로 사용돼 왔는지에 대해 설명


## 01. 프로시저 추상화와 데이터 추상화
현대적인 프로그래밍 언어를 특징 짓는 두 가지 추상화 메커니즘
### 프로시저 추상화
- 기능 분해

### 데이터 추상화
- 데이터 중심으로 타입을 추상화: 추상 데이터 타입
- 데이터 중심으로 프로시저를 추상화: 객체 지향

객체 지향? 데이터 추상화와 프로시저 추상화를 함꼐 포함한 클래스를 이용해 시스템을 분해하는 것  
전통적인 기능 분해방법와 객체 지향 분해 방법에 이르는 역사를 살펴 볼 것임  

## 02. 프로시저 추상화의 기능 분해
### 메인 함수로서의 시스템
- 기능 분해: 시스템을 프로시저 단위로 분해  
- 전통적인 기능 분해 방법: 하향식 접근

### 급여 관리 시스템
- 기능 분해의 결과: 최상위 기능을 수행하는데 필요한 절차들을 실행 시간 순서에 따라 나열한 것
- 유지보수에 다양한 문제 야기

### 급여 관리 시스템 구현
- 하향식 기능 분해: 최상위의 가장 추상적인 메인함수 정의 후, 구현 가능한 수준까지 세부적인 단계로 분해하는 방법

### 하향식 기능 분해의 문제점
1. 시스템은 하나의 메인함수로 구성돼 있지 않다.
2. 기능 추가나 요구사항 변경으로 메인함수를 빈번하게 수정
3. 비지니스 로직과 사용자 인퍼에시그가 강하게 결합
4. 유연성과 재사용 저하
5. 데이터 형식이 변경될 경우 파급효과 예측하기 어렵다 

#### 1. 하나의 메인함수는 비현실적이다.
- 대부분의 시스템은 하나의 메인기능이란 개념 존재 X
- 동등한 수준의 다양한 기능으로 구성

#### 2. 메인함수의 빈번한 재설계
- 하나의 메인함수만 있기 때문에 새로운 기능 추가시 매번 메인함수를 수정해야함
- 이러한 수정은 버그발생률을 높임

#### 3. 비즈니스 로직과 사용자 인터페이스의 결합
- 하향식 접근법은 설계초기단계부터 입력 방법과 출력양식을 고민하도록 강요
- 사용자로부터 소득세율을 입력받아 급여를 계산한 후 계산된 결과를 화면에 출력한다. : 비즈니스 로직과 사용자 인터페이스의 관심사가 섞여 있음
- 비즈니스 로직, 사용자 인터페이스의 변경 빈도가 다르다는게 문제: 변경에 불안정한 구조를 야기함

#### 4. 성급하게 결정된 실행 순서
- 하향식 접근법의 설계는 처음부터 구현을 염두에 두기 때문에 자연스럽게 함수들의 실행 순서를 정의하는 시간제약을 강조.
- 실행 순서가 결정되어야 함
- 상위 함수가 강요하는 문맥에 강하게 결합
- 다른 함수들과 시간적으로 강하게 결합되어 있음
- 재사용성 떨어짐

#### 5. 데이터 변경으로 인한 파급효과
- 어떤 데이터를 어떤 함수가 사용하고 있는지 추적하기 어렵다
- 데이터 변경으로 인한 영향을 최소화 하려면?: 데이터와 함꼐 변경되는 부분을 하나의 구현단위로 묶고 위부에서는 제공되는 함수만 이용해 데이터 접근
- 잘 정의된 퍼블릭 인터페이스를통해 데이터에 대한 접근을 통제해야함

-> 기능 분해가 가진 본질적인 문제를 해결하기 위해 데이비드 파나스는 정보 은닉과 모듈이라는 개념을 제시

### 언제 하향식 분해가 유용한가?
- 이미 완전히 이해된 사실을 서술하기에는 적합하다.
- 명확한 아이디어, 이미 해결된 알고리즘을 서술하는데 훌륭

## 03. 모듈

### 정보 은닉과 모듈
- 함께 변경되는 부분을 하나의 구현단위로 묶고 퍼블릭 인터페이스를 통해서만 접근하도록 만드는 것
- 자주 변경되는 부분을 상대적으로 덜 변경되는 안정적인 인터페이스 뒤로 감춤
- 모듈이라는게 결국 변경될 가능성이 있는 비밀을 내부로 감추고, 잘 정의되고 쉽게 변경되지 않을 퍼블릭 인터페이스를 외부에 제공  
- 모듈은 다음과 같은 두 가지 비밀을 감춰야 함: 복잡성, 변경 가능성
- 비밀이 반드시 데이터일 필요는 없다. (대부분의 경우는 데이터)

### 모듈의 장점과 한계

#### 모듈 내부의 변수가 변경되더라도 모듈 내부에만 영향을 미친다
#### 비지니스 로직과 사용자 인터페이스에 대한 관심사를 분리한다.
#### 전역 변수, 함수를 제거함으로써 네임스페이스 오염을 방지한다.

모듈의 핵심은 데이터이다. 모듈은 감춰야 할 데이터를 결정하고 이 데이터를 조작하는데 필요한 함수를 결정한다.   
기능이 아니라 데이터 중심으로 시스템을 분해함.
- 모듈의 가장 큰 단점은 인스턴스 개념을 제공하지 않는다. 
- 이를 만족시키기 위해 등장한 개념이 바로 추상 데이터 타입이다.

## 04. 데이터 추상화와 추상 데이터 타입
### 추상 데이터 타입
- 타입: 변수에 저장할 수 있는 내용물의 종류와 연산의 가짓수 -> 변수 값의 행동 예측
- 추상 데이터 타입을 구현하기 위한 언어 지원
1. 타입 정의 선언할 수 있어야 한다.
2. 타입의 인스턴스를 다루기 위해 사용할 수 있는 오퍼레이션의 집합을 정의할 수 있어야 한다.
3. 제공된 오퍼레이션을 통해서만 조작할 수 있도록 데이터를 외부로부터 보호할 수 있어야 한다. 
4. 타입에 대해 여러개의 인스턴스를 생성할 수 있어야 한다. 

## 05. 클래스
### 클래스는 추상 데이터 타입인가?
추상 데이터 타입, 클래스 모두 외부에서는 객체의 내부 속성에 직접 접근할 수 있으며 오직 퍼블릭 인터페이스를 통해서만 외부와 의사소통  
하지만 명확한 의미에서는 추상데이터 타입과 클래스는 동일하지 않다.  
- 클래스: 상속과 다형성 지원, 추상 데이터 타입: 지원 X
- 객체지향 프로그래밍: 상속과 다형성 지원, 객체기반 프로그래밍: 추상데이터 타입 기반

##### 추상 데이터 타입: 타입 추상화
- 하나의 대표적인 타입이 다수의 세부적인 타입을 감추기 때문에 타입 추상화
- 오퍼레이션 기준으로 타입을 통합하는 데이터 추상화 기법

##### 객체지향: 절차 추상화
- 다형성을 이용
- 타입을 기준으로 절차들을 추상화

### 추상 데이터 타입에서 클래스로 변경하기

### 변경을 기준으로 선택하라
- 타입을 기준으로 절차를 추상화하지 않았다면 그것은 객체지향 분해가 아니다. 
- 클래스 내부에 인스턴스 타입을 표현하는 변수가 있따면? 그리고 이 값을 기반으로 메서드 내에서 타입을 명시적으로 구분한다면? 객체지향 위반!
- 객체 지향에서는 타입 변수를 이용한 조건문을 다형성으로 대체한다. 
- 새로운 타입을 빈번하게 추가해야 한다면? 객체지향
- 새로운 오퍼레이션을 빈번하게 추가해야 한다면? 추상 데이터 타입



